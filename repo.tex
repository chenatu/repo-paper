\documentclass{acm_proc_article-sp}

\usepackage{url, fancyvrb, framed, multirow}

\begin{document}

\title{NDN Repo: An NDN Persistent Storage Model}

\numberofauthors{3}

\author{
% 1st. author
\alignauthor
Shuo Chen\\
	\affaddr{Research Institute of Information}\\
	\affaddr{Tsinghua University}\\
	\affaddr{Beijing, China}\\
	\email{chenatu2006@gmail.com}
}
\maketitle

\begin{abstract}
NDN repository (Repo for short) is persistent storage model of Named Data Networking NDN compared with NDN Content Store. NDN makes in-network storage possible because of naming and signature of network layer data packet. NDN repo is not a built-in part of NDN, but built upon application layer without tweaking NDN protocol. A specification of NDN Repo is designed to standardize repo operation interfaces. Fetching, insertion and deletion of data objects are supported in this specification and basic semantics of repo commands is defined.

In this paper, details of NDN repo specification are demonstrated and an initial implementation based on ndn-cpp library and sqlite3 is presented. (Something about the evaluation results)
\end{abstract}

\section{Introduction}
Named Data Networking (NDN) \cite{zhang2010named} is a data-oriented network architecture which replaces ip with data names as narrow waist of networking. The essential evolution of NDN is the change of network behavior from delivering data to a certain destination to fetching data with a given name. \cite{zhang2010named} Because of this change, \emph{interest} and \emph{content object} are two kinds of network packet for fetching and returning data of given name. \emph{Interest} is the request of data containing prefix of name and other constraints of data. Besides the content of data, content object also contains the complete name and signature of data.

Naming and signature of data makes in-network storage possible because of the following reason. Network packet in named by source and destination host addresses in IP network, while name of NDN packet is irrelevant with physical endpoints. Any host in NDN network carrying data of given name can response to the \emph{interest}, but hosts besides source and destination cannot retrieve in-network IP packet. Another concern is the privacy of in-network data. Signature in data packet is to resolve authentication and confidentiality of data. \emph{Content Store (CS)} is cache of data packet in NDN router model and it is within network layer. NDN repository (Repo for short) is persistent NDN storage model. It is an application conforming to NDN protocol and can be used as storage functional components by other NDN applications such as video streaming and CDN like applications.

\emph{Ccnr} proposed by Project CCNx just provides read and write access of content object. It does not support deletion of content object and does not provide validation and access control. Compared to CCNx Repository Protocols \cite{ccnr}, a more functional specification is proposed to provides remote operations of repo in this paper. Three basic functions including retrieving, inserting and deleting \emph{content objects} are supported in addition with check of insertion and deletion progress. The specification provides semantics of command to support remote control over repo and signature of command to support validation and access control.

An implementation of NDN repo protocol called \emph{repo-ng} (repo of new generation) is also demonstrated in this paper. Repo-ng is based on ndn-cpp library and sqlite3. Its backend storage is built on sqlite3 database. Wired format data packet is directly stored in database. \emph{repo-ng} uses hierarchical trust model referred to NDN testbed. \cite{ndn-key} \emph{Repo-ng} also gives medium granularity of access control.

The rest of the paper is organized as follows...

\section{NDN REPO PROTOCOL DESIGN}
\subsection{Overview}
A repo supports the network by preserving content and responding to \emph{interests} requesting content that it holds. A Repo can exist in any node, and is recommended if applications in that node need to preserve data. The NDN repo protocol is a specification of repo operations including reading, insertion and deletion of \emph{content objects} in repo. Compared to \emph{ccnr} proposed in Project CCNx, insertion and deletion are supported in this protocol by \emph{repo command}. Although validation trust model and access control of \emph{repo command} are not stipulated, an example is given in the following implementation \emph{repo-ng}.

Retrieving data from repo is just like common ways of retrieving data from NDN network. \emph{Repo command} based on command interest with signed components is used to support insertion and deletion function. Validation and access control can be designed based on signed components. A new repo semantics different from NDN semantics is defined for repo command.

\subsection{Retrieving Data}
Repo registers prefixes of data objects it holds into NDN forwarding daemon (NFD) and the repo will respond the data with such prefixes. A standard interest is used to fetch content from the repo. The repo will respond when the name of the interest matches the prefix it registered in NFD. If the content in repo matches the interests, it will respond with the \emph{content object}. When the interest is not matched, it will not respond. The following figures shows the process of retrieving data.

\begin{figure}
\centering
\begin{BVerbatim}
Requester                     Repo
    |                           |
    |                           |
    |         Interest          |
 t1 |-------------------------->|
    |                           |
    |        Data Object        |
 t2 |<==========================|
    |                           |
    |                           |
    |                           |
\end{BVerbatim}
\caption{Fetch data that matches in repo}
\end{figure}

\begin{figure}
\centering
\begin{BVerbatim}
Requester                     Repo
    |                           |
    |                           |
    |         Interest          |
 t1 |-------------------------->|
    |                           |
    |                           |
    |                           |
\end{BVerbatim}
\caption{Fetch data that does not match in repo}
\end{figure}

\subsection{Repo Command and Repo Command Response}
Four types of commands are supported in repo protocol: insertion, deletion, insertion progress check and deletion progress check. Repo command is a kind of interest based on semantics of signed command interests. Repo command response is a specific type of NDN data packet conforming to the following specification.

\subsubsection{Background}
NDN packets are encoded in a Type-Length-Value (TLV) format. One TLV block can be nested with servral sub TLV bocks and the length of each TLV block is variable. The type of block is defined in the first few octets and the length of block is set subsequently. Wired format of name is just a sub TLV block of interest and all the components of name are nested in the name block.

Repo command interests are based on signed command interests. Signed command interests are used for authentication. The signed command interests not only contain cryptographic signature, but also ensure uniqueness of each command. The following name is a typical structure of name of singed common interest:

\begin{figure*}[htbp]
\centering
\begin{framed}
\begin{BVerbatim}
 /signed/interest/name/<timestamp>/<random-value>/<SignatureInfo>/<SignatureValue>
                       \                                                         /
                        -------------------------  ------------------------------
                                                \/
                              Additional components of Command Interest 
\end{BVerbatim}
\end{framed}
\end{figure*}

The first three components are the actual content of content. n denotes the count of components of name. The n-3th is the timestamp of command to protect replay attack. The n-2th is random value that guarantee the uniqueness of the command. The n and n-1th components are signature and signature info of the interest for validation.

\subsubsection{Repo Command}
For insertion, deletion and other operations of repo, these commands are encoded in the form of signed command interest. The semantics of repo command interest is as follows:

The name semantics is defined to have following components:
\begin{itemize}
\item <repo prefix> refers to specific prefix repo is listening
\item <command verb> refers to the name of command
\item <RepoCommandParameter> refers to parameters of repo command
\end{itemize}

The following components are components of singed interest for access control:
\begin{itemize}
\item <timestamp>
\item <random-value>
\item <SignatureInfo>
\item <SignatureValue>
\end{itemize}

For prefix of repo /ucla/cs/repo/, the command will be defined as this:

\begin{figure*}
\begin{framed}
\begin{BVerbatim}
/ucla/cs/repo/<command verb>/<RepoCommandParameter>/<timestamp>/<random-value>/<SignatureInfo>
/<SignatureValue>
\end{BVerbatim}
\end{framed}
\end{figure*}

The RepoCommandParatmeter component is also nested with sub TLV component. It defines as follows:

\begin{figure*}
\begin{framed}
\begin{BVerbatim}
RepoCommandParameter ::= REPOCOMMANDPARAMETER-TYPE TLV-LENGTH
                           Name?
                           Selectors?
                           StartBlockId?
                           EndBlockId?
                           ProcessId?

Name                  ::= NAME-TYPE TLV-LENGTH NameComponent*
NameComponent         ::= NAME-COMPONENT-TYPE TLV-LENGTH BYTE+

Selectors             ::= SELECTORS-TYPE TLV-LENGTH
                           MinSuffixComponents?
                           MaxSuffixComponents?
                           PublisherPublicKeyLocator?
                           Exclude?
                           ChildSelector?

MinSuffixComponents   ::= MIN-SUFFIX-COMPONENTS-TYPE TLV-LENGTH
                           nonNegativeInteger

MaxSuffixComponents   ::= MAX-SUFFIX-COMPONENTS-TYPE TLV-LENGTH
                           nonNegativeInteger

PublisherPublicKeyLocator ::= KeyLocator

Exclude               ::= EXCLUDE-TYPE TLV-LENGTH Any? (NameComponent (Any)?)+
Any                   ::= ANY-TYPE TLV-LENGTH(=0)

ChildSelector         ::= CHILD-SELECTOR-TYPE TLV-LENGTH
                           nonNegativeInteger

StartBlockId          ::= STARTBLOCKID-TYPE TLV-LENGTH
                           nonNegativeInteger

EndBlockId            ::= ENDBLOCKID-TYPE TLV-LENGTH
                           nonNegativeInteger

ProcessId             ::= PROCESSID-TYPE TLV-LENGTH
                           nonNegativeInteger
\end{BVerbatim}
\end{framed}
\end{figure*}

Name adopts the same TLV structure of name of interest and data packet. This name denotes the name of possessed data. Selectors adopt the same TLV structure of selector. However, only parts of selectors including MinSuffixComponents, MaxSuffixComponents, PublisherPublicKeyLocator, Exclude, ChildSelector are used in repo command parameter. The meaning of selectors is not the same in different operations which will be discussed in the following sections. StartBlockId and EndBlockId denotes the beginning and end of segment number to support segmented insertion and deletion. ProcessId is a random number generated to identify operation process. It is used for insertion and deletion progress check.

\subsubsection{Repo Command Response}
Repo command response is the response data packet of repo command interest. The response contains statuscode to indicate the status of command process and other information. A TLV-encoded block called RepoCommandResponse is encoded in content of the data packet. It defines as follows:

\begin{figure*}
\begin{framed}
\begin{BVerbatim}
RepoCommandResponse   ::= INSERTSTATUS-TYPE TLV-LENGTH
                           ProcessId?
                           StatusCode
                           StartBlockId?
                           EndBlockId?
                           InsertNum?
                           DeleteNum?

ProcessId             ::= PROCESSID-TYPE TLV-LENGTH
                            nonNegativeInteger 

StatusCode            ::= STATUSCODE-TYPE TLV-LENGTH
                            nonNegativeInteger    

StartBlockId          ::= STARTBLOCKID-TYPE TLV-LENGTH
                            nonNegativeInteger

EndBlockId            ::= ENDBLOCKID-TYPE TLV-LENGTH
                            nonNegativeInteger

InsertNum             ::= INSERTNUM-TYPE TLV-LENGTH
                            nonNegativeInteger

DeleteNum             ::= DELETENUM-TYPE TLV-LENGTH
                            nonNegativeInteger

\end{BVerbatim}
\end{framed}
\end{figure*}

The TLV structure and meaning of Name, ProcessId, StartBlockId, and EndBlockId are just like those of RepoCommandParameter. InsertNum is the count of data inserted. DeleteNum is the count of data deleted. Statuscode is the number indicating the status of command. The detailed definition will be introduced in the following sections.

\subsubsection{Repo TLV Type Encoding Number}

In TLV encoding, first several bits defines the type of block. Table 1 shows the 

\begin{table}[!hbp]
\centering

\begin{tabular}{l l}

\hline
type & number \\
\hline
RepoCommandParameter & 201 \\
StartBlockId & 204 \\
EndBlockId & 205 \\
ProcessId & 206 \\
RepoCommandResponse & 207\\
StatusCode & 208 \\
InsertNum & 209 \\
DeleteNum & 210 \\
\hline

\end{tabular}
\caption{Repo TLV Type Encoding Number}
\end{table}



\subsection{Authentication and Authorization}
The trust model and access control of repo depends on specific implementation. The protocol does not limit type of trust model. The implementation of repo can either adopt policy based or reputation based trust model for validation the repo command interest. The protocol only requests signature and timestamp of repo command interest. Access control is also defined by implementation. Public key in signature is a good identifier for access control list.

\subsection{Inserting Data and Insertion Status Check}

Repo insertion command requests that the repo retrieves and stores content from requester. Validation of commands is defined by specific implementation. When the interested is validated and name of the data is not existed in the repo. The repository will response with a data object containing OK status and start to send the interest to fetch the data to insert.

Segmented data insertion is also supported in the insertion protocol. Segmentation information is also defined in RepoCommandParameter.

Command of insertion status check is supported. Once the check command was sent, repo will return response about the first and the last of id of segmented data and how many blocks have been inserted. If EndBlockId Missing Timeout is allowed, this check command can also reset the timer to zero.

\subsubsection{Structure of Repo Insertion Command and Insertion Check Command}
The name semantics follows the format of the repo command. The ``<command verb>'' are defined as ``insert'' and ``insert check''. For example, for <repo prefix> as /ucla/cs/repo, the following are an examples of insertion and insertion check command:

\begin{figure*}
\begin{framed}
\begin{BVerbatim}

/ucla/cs/repo/insert/<RepoCommandParameter>/<timestamp>/<random-value>/<SignatureInfo>/<SignatureValue>

\end{BVerbatim}
\end{framed}
\end{figure*}

\begin{figure*}
\begin{framed}
\begin{BVerbatim}

/ucla/cs/repo/insert check/<RepoCommandParameter>/<timestamp>/<random-value>/<SignatureInfo>/<SignatureValue>

\end{BVerbatim}
\end{framed}
\end{figure*}


\subsubsection{RepoCommandParameter of Insertion Command}
RepoCommandParameter of insertion command follows TLV structure of RepoCommandParameter of repo command, but adopts only parts of sub TLV-block including, Name, Selector, StartBlockId, EndBlockId. The name section is a must section in this scenario.

\begin{itemize}
\item <Name> indicates the prefix of name of data that will be inserted into repo.
\item <Selector> indicates the selectors of interests for repo to fetch data.
\item <StartBlockId> indicates the first segment ID of segmented data to be inserted.
\item <EndBlockId> indicates the last segment ID of segmented data to be inserted.
\end{itemize}

\subsubsection{RepoCommandParameter of Insertion Check Command}
RepoCommandParameter of insertion check command follows TLV structure of RepoCommandParameter of repo command, but only and must adopt ProcessId.

\begin{itemize}
\item <ProcessId> is retrieved from the RepoCommandResponse of Insertion Command and it indicates the identity of the insertion progress.
\end{itemize}

\subsubsection{RepoCommandResponse of Insertion Command}
RepoCommandResponse of insertion command follows TLV structure of RepoCommandResponse of repo. Once the interest arrives, repo will validate the command interest and check the authorization of the command. Then Repo will return the response according to the result of command validation. RepoCommandResponse of insertion adopts ProcessId, StatusCode, StartBlockId, EndBlockId, and InsertNum sections. StatusCode is the must section.

\begin{itemize}
\item <ProcessId> is generated when the interest is validated and authorized. If the response is negative
\item <StatusCode> indicates status of insertion status.
\item <StartBlockId> indicates the first segment ID of segmented data to be inserted.
\item <EndBlockId> indicates the last segment ID of segmented data to be inserted.
\item <InsertNum> indicates how many content objects have been inserted.
\end{itemize}

\subsubsection{RepoCommandResponse of Insertion Check Command}
RepoCommandResponse of insertion check command follows TLV structure of RepoCommandResponse of repo. Once the interest arrives, repo will validate the command interest and check the authorization of the command. Then Repo will check the insertion status according to ProcessId. RepoCommandResponse of insertion check adopts ProcessId, StatusCode, StartBlockId, EndBlockId, and InsertNum sections. StatusCode and ProcessId are the must sections.

\begin{itemize}
\item <ProcessId> is the same with that of insertion response.
\item <StatusCode> indicates status of insertion progress.
\item <StartBlockId> indicates the first segment ID of segmented data to be inserted.
\item <EndBlockId> indicates the last segment ID of segmented data to be inserted.
\item <InsertNum> indicates how many content objects have been inserted.
\end{itemize}

The following table shows the definition of StatusCode.

\begin{table}[!hbp]
\centering

\begin{tabular}{l l}

\hline
StatusCode & Description \\
\hline
100 & The command is OK. can start to fetch the data \\
200 & All the data has been inserted \\
300 & This insertion is in progress \\
401 & This insertion command or insertion check command is invalidated \\
402 & Selectors and BlockId both present\\
403 & Malformed Command \\
404 & No such this insertion is in progress \\
\hline

\end{tabular}
\caption{StatusCode of Insertion}
\end{table}

\subsubsection{Types of Insertion}
There are 3 types of supported insertion: single, selector and segment.

Single insertion means inserting one content object of prefix of Name into the repo. Selector, StartBlockId and EndBlockId are all not set, except Name of RepoCommandParameter.

Selector insertion means inserting one content object conforming to Name as prefix and Selector. StartBlockId and EndBlockId will not be set. Name and Selector will be set.

Segment insertion means inserting multiple segmented content objects into the repo. Selector will not be set. At least one of StartBlockId and EndBlockId is set.

\subsubsection{EndBlockId Missing Timeout}
If StartBlockId presents but EndBlockId is missing, and returned data packets do not contain FinalBlockId, the repo will continuously fetch the data. An EndBlockId missing timeout is set to prevent this occasion. The repo will start a timer when StartBlockId presents but EndBlockId is missing. When timeout happens, repo will stop fetching data to store and end insert process. If an insert check command arrives during this insert process, the time of timer is set to 0. If data packet containing FinalBlockId arrives, this timeout timer will be dismissed.

\subsubsection{Protocol Process}

Progress of Inserting Data:

\begin{enumerate}

\item start to authorize the command; if authorization does not fail immediately, go to step 3

\item send a negative response indicating authorization failure, and abort these steps, insert process ends (StatusCode: 401)

\item if both StartBlockId and EndBlockId are missing, go to step 7

\item if either StartBlockId or EndBlockId is present, and one of supported selectors is present. send negative response back and abort steps, insert process ends (StatusCode: 402)

\item if both StartBlockId and EndBlockId are present, and StartBlockId is less than or equal to EndBlockId, go to step 7

\item send a negative response indicating malformed command, and abort these steps, insert process ends (StatusCode: 403)

\item wait for authorization completion

\item if authorization fails, go to step 2 (StatusCode: 401)

\item send a positive response indicating insert is in progress (StatusCode: 200)

\item if either StartBlockId or EndBlockId is present, go to step 16

\item start to retrieve Name with selectors in insert command

\item wait for retrieval completion

\item if retrieval fails, go to step 27

\item store retrieved Data packet

\item abort these steps, insert process ends

\item if StartBlockId is missing, set StartBlockId 0. If EndBlockId is missing, EndBlockId will be missing unless get FinalBlockId in coming data packets, start EndBlockId Missing Timeout timer.

\item append StartBlockId to Name

\item start to retrieve Name

\item wait for retrieval completion

\item if retrieval fails, go to step 26

\item store retrieved Data packet

\item if retrieved Data packet contains FinalBlockId, and FinalBlockId is less than EndBlockId or EndBlockId is missing, let EndBlockId be FinalBlockId

\item if the last component of Name is greater than or equal to EndBlockId, abort these steps, insert process ends

\item increment the last component of Name

\item go to step 17

\item retrieve data with this data another 2 times. If these 2 retrieval both fails, abort these steps. if success, go to step 20

\item retrieve data with this data another 2 times. If these 2 retrieval both fails, abort these steps. if success, go to step 13
\end{enumerate}

If EndBlockId Missing Timeout timer starts, repo will monitor this timer during step 17~26. If this timeout occurs, abort insert command process immediately.

Implementation MAY pipeline the Interests.

Progress of Insertion Check:

Implementation MAY publish a notification of status regarding insert progress. The process of insertion check is as follows:

\begin{enumerate}

\item start to authorize the insert status command, if fails go to 2, if success, go to 3

\item send a negative response indicating authorization failure, and abort these steps (StatusCode: 401)

\item start to check the progress of the insert with the data name in the command. If no such progress is found, go to 4. or go to 5.

\item response status with status code, abort check process. (StatusCode: 404)

\item check the status of insertion. return the status of insertion progress. If a EndBlockId Missing Timeout timer is running, set this timer to 0. About check process. (StatusCode: 300)

\end{enumerate}

\begin{figure*}
\centering
\begin{BVerbatim}
Requester                     Repo                          Data producer
    |                           |                                 |
    |                           |                                 |
  +---+  Insert command       +---+                               |
  |   | --------------------> |   |                               |
  +---+                       |   |                               |
    |                         |   |                               |
  +---+   Confirm start       |   |                               |
  |   | <==================== |   |                               |
  +---+   Reject command      +---+                               |
    |     (with status code)    |                                 |
    |                         +---+     Interest for Data       +---+
    |                         |   | --------------------------> |   |
    |                         +---+                             |   |
    |                           |                               |   |
    |                         +---+       Data segment          |   |
    |                         |   | <========================== |   |
    |                         +---+                             +---+
    |                           |                                 |
    |                           ~                                 ~
    |                           ~                                 ~
    |                           |                                 |
    |                         +---+     Interest for Data       +---+
    |                         |   | --------------------------> |   |
    |                         +---+                             |   |
    |                           |                               |   |
    |                         +---+       Data segment          |   |
    |                         |   | <========================== |   |
    |                         +---+                             +---+
    |                           |                                 |
    |                           |                                 |
    |                           ~                                 ~
    |                           ~                                 ~
    |                           |                                 |
    |                           |                                 |
    |                           |                                 |
  +---+    Check interest     +---+                               |
  |   | --------------------> |   |                               |
  +---+                       |   |                               |
    |                         |   |                               |
  +---+    Check response     |   |                               |
  |   | <==================== |   |                               |
  +---+                       +---+                               |
    |                           |                                 |
    |                           |                                 |
\end{BVerbatim}
\caption{Insertion and Insertion Check Progress}
\end{figure*}

\subsection{Deleting Data and Deletion Status Check}
Deletion of one content object or multiple content objects under certain prefix are both supported. Selectors can be used in deletion but has different semantics with that of insertion.

\subsubsection{Structure of Repo Deletion and Deletion Status Check Command}
The name semantics follows the format of the repo command. The ``<command verb>'' are defined as ``delete'' and ``delete check''. For example, for <repo prefix> as /ucla/cs/repo, the following are an examples of deletion and deletion check command:

\begin{figure*}
\begin{framed}
\begin{BVerbatim}

/ucla/cs/repo/delete/<RepoCommandParameter>/<timestamp>/<random-value>/<SignatureInfo>/<SignatureValue>

\end{BVerbatim}
\end{framed}
\end{figure*}

\begin{figure*}
\begin{framed}
\begin{BVerbatim}

/ucla/cs/repo/delete check/<RepoCommandParameter>/<timestamp>/<random-value>/<SignatureInfo>/<SignatureValue>

\end{BVerbatim}
\end{framed}
\end{figure*}

\subsubsection{RepoCommandParameter of Deletion Command}
RepoCommandParameter of deletion command follows TLV structure of RepoCommandParameter of repo command, and adopts all the sub-sections. The Name and ProcessId sections are the must sections in this scenario.

\begin{itemize}
\item <ProcessId> is generated by the deletion requester and it indicates the identity of the deletion progress.
\item <Name> indicates the prefix of name of data that will be deleted from repo.
\item <Selector> indicates the selectors of interests for repo to deleting data.
\item <StartBlockId> indicates the first segment ID of segmented data to be deleted.
\item <EndBlockId> indicates the last segment ID of segmented data to be deleted.
\end{itemize}

\subsubsection{RepoCommandParameter of Deletion Check Command}
RepoCommandParameter of deletion check command follows TLV structure of RepoCommandParameter of repo command, but only and must adopt ProcessId.

\begin{itemize}
\item <ProcessId> is that of deletion command to indicate the specific deletion progress.
\end{itemize}


\subsubsection{RepoCommandResponse of Deletion Command}
RepoCommandResponse of deletion command follows TLV structure of RepoCommandResponse of repo. Once the interest arrives, repo will validate the command interest and check the authorization of the command. Then Repo will start deletion prgress. When the deletion is complished, repo will return the response. RepoCommandResponse of deletion adopts ProcessId, StatusCode, StartBlockId, EndBlockId, and DeleteNum sections. StatusCode is the must section.

\begin{itemize}
\item <ProcessId> is generated by the deletion command interest;
\item <StatusCode> indicates status of deletion status.
\item <StartBlockId> indicates the first segment ID of segmented data to be deleted.
\item <EndBlockId> indicates the last segment ID of segmented data to be deleted.
\item <DeleteNum> indicates how many content objects have been deleted.
\end{itemize}

\subsubsection{RepoCommandResponse of Deletion Check Command}
RepoCommandResponse of deletion check command follows TLV structure of RepoCommandResponse of repo. Once the interest arrives, repo will validate the command interest and check the authorization of the command. Then Repo will check the deletion status according to ProcessId. RepoCommandResponse of deletion check adopts ProcessId, StatusCode, StartBlockId, EndBlockId, and DeleteNum sections. StatusCode and ProcessId are the must sections.

\begin{itemize}
\item <ProcessId> is the same with that of deletion command.
\item <StatusCode> indicates status of deletion command.
\item <StartBlockId> indicates the first segment ID of segmented data to be deleted.
\item <EndBlockId> indicates the last segment ID of segmented data to be deleted.
\item <DeleteNum> indicates how many content objects have been deleted.
\end{itemize}

The following table shows the definition of StatusCode.

\begin{table}[!hbp]
\centering

\begin{tabular}{l l}

\hline
StatusCode & Description \\
\hline
200 & All the data has been deleted \\
300 & This deletion is in progress \\
401 & This deletion or deletion check command is invalidated \\
402 & Selectors and BlockId both present\\
403 & Malformed Command \\
404 & No such this deletion  is in progress \\
\hline

\end{tabular}
\caption{StatusCode of Deletion}
\end{table}

\subsubsection{Types of Deletion}
There are 3 types of supported deletion: single, selector and segment.

Single deletion means deleting one content object of prefix of Name from the repo. Selector, StartBlockId and EndBlockId are all not set, except Name of RepoCommandParameter.

Selector deletion means deleting any content object conforming to Name as prefix and Selector. StartBlockId and EndBlockId will not be set. Name and Selector will be set.

Semantics of selectors in this case is different. In this case, the selector will match any content object conforming to the selector conditions not just one content object.

Segment deletion means deleting multiple segmented content objects from the repo. Selector will not be set. At least one of StartBlockId and EndBlockId is set.

\subsubsection{Protocol Process}

Progress of Deleting Data:

\begin{enumerate}

\item start to authorize the command; if authorization does not fail, go to step 3

\item send a negative response indicating authorization failure, and abort these steps, end deletion process. (StatusCode: 401)

\item check whether a deletion process of same RepoCommandParameter exists, waiting for deletion process ends.

\item If selectors and one of StartBlockId and EndBlockId presents, send a negative response and abort these steps, end deletion process. (StatusCode: 402)

\item If selectors present, go to step 8

\item check whether StartBlockId or EndBlockId presents. If both presents but StartBlockId is larger than EndBlockId, return negative response and end deletion process. (StatusCode: 403) Or go to step 9

\item If StartBlockId, EndBlockId and selectors are all missing, go to step 10

\item delete all the data that conforms to the name and selectors, go to step 11

\item delete all the data packets of segment id between StartBlockId and EndBlockId. If StartBlockId is missing, StartBlockId is set to be 0. If EndBlockId is missing, EndBlockId is set to be the largest segment id that repo holds. go to step 11

\item delete data exact matches the name. got to step 11

\item If lifetime of interest does not expire, return status response of positive StatusCode. If lifetime of interest has expired, wait for interest the same RepoCommandParameter and return this status response. End Deletion process. (StatusCode: 200)

\end{enumerate}

Client will set deletion command with big lifetime. The repo will also hold the status of deletion progress for certain time after deletion done. If life time expires, client will re-express the command to get the response.

Implementation MAY publish a notification of status regarding delete progress. The process of status check is as follows:

\begin{enumerate}

\item start to authorize the delete status command

\item send a negative response indicating authorization failure, and abort these steps (StatusCode: 401)

\item start to check the progress of the delete with the data name in the command. If no such progress is found, go to 4. or go to 5.

\item response status with status code of 404 (StatusCode: 404)

\item check the status of delete. return the status data content (StatusCode: 300)

\end{enumerate}

\begin{figure*}
\centering
\begin{BVerbatim}

Requester                     Repo 
    |                           |                                 
    |                           |                                 
  +---+  Delete command       +---+                               
  |   | --------------------> |   |                               
  +---+                       +---+                               
    |                           |                                 
    |                           |                                 
    |                           |                                 
  +---+   Status interest     +---+                               
  |   | --------------------> |   |                               
  +---+                       |   |                               
    |                         |   |                               
  +---+    Status response    |   |                               
  |   | <==================== |   |                               
  +---+                       +---+                               
    |                           |                                 
    |                           |                                 
    |                           |                                 
  +---+   Confirm Deletion    +---+                               
  |   | <==================== |   |                               
  +---+   Reject command      +---+                               
    |     (with status code)    |    
    |                           |

\end{BVerbatim}
\caption{Deletion and Deletion Check Progress}
\end{figure*}


\section{REPO-NG DESIGN}

\section{EVALUTATION OF REPO-NG}

\section{CONCLUSION AND FUTURE WORK}

\bibliographystyle{abbrv}
\bibliography{repo}

\end{document}

