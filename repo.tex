\documentclass{acm_proc_article-sp}

\usepackage{url, fancyvrb, framed, multirow, tabularx, graphicx, epstopdf, enumerate}

\begin{document}

\title{NDN Repo: An NDN Persistent Storage Model}

\numberofauthors{3}

\author{
% 1st. author
\alignauthor
Shuo Chen\\
	\affaddr{Research Institute of Information}\\
	\affaddr{Tsinghua University}\\
	\affaddr{Beijing, China}\\
	\email{chenatu2006@gmail.com}
}
\maketitle

\begin{abstract}
NDN repository (repo for short) is persistent storage model of Named Data Networking, compared with NDN Content Store. NDN makes in-network storage possible because of naming and signature of network layer data packet. NDN repo is not a built-in part of NDN, but built upon application layer without tweaking NDN protocol. A specification of NDN repo is designed to standardize repo operation interfaces. Retrieval, insertion and deletion of data objects are supported in this specification and basic semantics of repo commands is defined.

In this paper, details of NDN repo specification are demonstrated and an initial implementation based on ndn-cxx library and sqlite3 is presented. (Something about the evaluation results)

\end{abstract}

\section{Introduction}
Named Data Networking (NDN) \cite{zhang2010named} is a data-oriented network architecture which replaces IP with names of the data packets as narrow waist of networking. The essential evolution of NDN is the change of network behavior from delivering data to a certain destination to fetching data with a given name. \cite{zhang2010named} Because of this change, \emph{interest} and \emph{data object} are two kinds of network packet for fetching and returning data of given name. \emph{Interest} is the request of network packet containing prefix of name and other constraints. Besides the content of data packet, data packet also contains the full name and signature of data.

Naming and signature of data makes in-network storage possible because of the following reasons. Network packet in named by source and destination host addresses in IP network, while name of NDN packet is irrelevant with physical endpoints. Any host in NDN network carrying data of given name can response to the \emph{interest}, but hosts besides source and destination cannot retrieve in-network IP packet. Another concern is the privacy of in-network data. Signature in data packet is to resolve authentication and confidentiality of data. \emph{Content Store (CS)} is cache of data packet in NDN router model and it is within network layer. NDN repository (Repo for short) is persistent NDN storage model. It is an application conforming to NDN protocol and can be used as storage functional components by other NDN applications such as video streaming and CDN like applications.

\emph{Ccnr} proposed by Project CCNx, which also serves as persistent storage of data packets just provides read and write access of content object. It does not support deletion of data packet and does not provide any validation and access control. Compared to CCNx Repository Protocol, a more functional specification is proposed to provide remote operations of repo in this paper. Three basic functions including retrieving, inserting and deleting data packets are supported in addition with check of insertion and deletion progress. Validation of command interest is supported for authentication.

An implementation of NDN repo protocol \emph{repo-ng} (repo of new generation) is also demonstrated in this paper. The NDN repo protocol is implemented in repo-ng. It is developed with ndn-cxx and uses sqlite3 for storage of data packets and in-memory index for high speed query.

The rest of the paper is organized as follows: section 2 demonstrates the details of NDN repo protocol, section 3 describes the implementations of repo-ng, section 4 evaluated the performance of repo-ng and section 5 concludes the paper and discusses the future work.

\section{NDN REPO PROTOCOL DESIGN}
\subsection{Overview}

A repo preserves content and responds to interests requesting content that it holds. A Repo can exist in any node, and is recommended for applications to preserve the data. The NDN repo protocol is a specification of repo operations including reading, insertion and deletion of emph{content objects} in repo. Compared to \emph{ccnr} proposed in Project CCNx, insertion and deletion are supported in this protocol by \emph{signed command interest}. The repo protocol does not stipulated on certain trust model, but practical application could define its trust model and policy of access control.

Retrieving data from repo is just like common ways of retrieving data from NDN network. \emph{Repo command} based on singed interest is used to support insertion and deletion function. Validation and access control can be designed based on signed components. A new repo semantics different from NDN semantics is defined for \emph{repo command}.

\subsection{Retrieving Data}

Repo registers prefixes of data objects it holds into NDN forwarding daemon (NFD) and the repo will respond the data with such prefixes. A standard interest is used to fetch content from the repo. The repo will start to search the data packet when the name of the interest matches the prefix it registered in NFD. If the data packet in repo matches the interest, it will respond with this \emph{data packet}. When the interest is not matched, it will not respond. The following figures shows the process of retrieving data.

\begin{figure}
\centering
\includegraphics{Drawing1.eps}
\caption{Retrieving data that matches in repo}
\end{figure}

\begin{figure}
\centering
\includegraphics{Drawing2.eps}
\caption{Retrieving data that does not match in repo}
\end{figure}

\subsection{Repo Command and Repo Command Response}
Four types of commands are supported in repo protocol: insertion, deletion, insertion status check and deletion status check. Repo command is a based on signed interest \cite{signed-interest}. Repo command response is a specific type of NDN data packet conforming to the following specification.

\subsubsection{Background}
NDN packets \cite{ndn-packet} are encoded in a Type-Length-Value (TLV) format. One TLV block can be nested with servral sub TLV bocks and the length of each TLV block is variable. The type of block is defined in the first few octets and the length of block is set subsequently. Wired format of name is just a sub TLV block of interest and all the components of name are nested in the name block.

Repo command interests are based on signed interests. Signed interests is used for authentication. The signed interests not only contain cryptographic signature, but also ensure uniqueness of each command. The following name is a typical structure of name of singed interest. For /signed/interest/name name, Command Interest will be defined as:

\begin{figure*}[htbp]
\centering
\begin{framed}
\begin{BVerbatim}
 /signed/interest/name/<timestamp>/<random-value>/<SignatureInfo>/<SignatureValue>
                       \                                                         /
                        -------------------------  ------------------------------
                                                \/
                              Additional components of Command Interest
\end{BVerbatim}
\end{framed}
\end{figure*}

n denotes the count of components of name. The n-3th is the timestamp of command to protect replay attack. The n-2th is random value that guarantee the uniqueness of the command. The n and n-1th components are signature and signature info of the interest for validation.

\subsubsection{Repo Command}
Repo commands are encoded in the form of signed interest. The semantics of repo command interest is as follows.

The name semantics is defined to have following components:

\begin{itemize}
\item <repo prefix> refers to specific prefix repo is listening
\item <command verb> refers to the name of command
\item <RepoCommandParameter> refers to parameters of repo command
\end{itemize}

The following components are components of singed interest for access control:
\begin{itemize}
\item <timestamp>
\item <random-value>
\item <SignatureInfo>
\item <SignatureValue>
\end{itemize}

For prefix of repo /ucla/cs/repo/, the command will be defined as this:

\begin{figure*}
\begin{framed}
\begin{BVerbatim}
/ucla/cs/repo/<command verb>/<RepoCommandParameter>/<timestamp>/<random-value>/<SignatureInfo>
/<SignatureValue>
\end{BVerbatim}
\end{framed}
\end{figure*}

The RepoCommandParatmeter component is also nested with sub TLV component. It defines as follows:

\begin{figure*}
\begin{framed}
\begin{BVerbatim}
RepoCommandParameter ::= REPOCOMMANDPARAMETER-TYPE TLV-LENGTH
                           Name?
                           Selectors?
                           StartBlockId?
                           EndBlockId?
                           ProcessId?

Name                  ::= NAME-TYPE TLV-LENGTH NameComponent*
NameComponent         ::= NAME-COMPONENT-TYPE TLV-LENGTH BYTE+

Selectors             ::= SELECTORS-TYPE TLV-LENGTH
                           MinSuffixComponents?
                           MaxSuffixComponents?
                           PublisherPublicKeyLocator?
                           Exclude?
                           ChildSelector?

MinSuffixComponents   ::= MIN-SUFFIX-COMPONENTS-TYPE TLV-LENGTH
                           nonNegativeInteger

MaxSuffixComponents   ::= MAX-SUFFIX-COMPONENTS-TYPE TLV-LENGTH
                           nonNegativeInteger

PublisherPublicKeyLocator ::= KeyLocator

Exclude               ::= EXCLUDE-TYPE TLV-LENGTH Any? (NameComponent (Any)?)+
Any                   ::= ANY-TYPE TLV-LENGTH(=0)

ChildSelector         ::= CHILD-SELECTOR-TYPE TLV-LENGTH
                           nonNegativeInteger

StartBlockId          ::= STARTBLOCKID-TYPE TLV-LENGTH
                           nonNegativeInteger

EndBlockId            ::= ENDBLOCKID-TYPE TLV-LENGTH
                           nonNegativeInteger

ProcessId             ::= PROCESSID-TYPE TLV-LENGTH
                           nonNegativeInteger
\end{BVerbatim}
\end{framed}
\end{figure*}

Name adopts the same TLV structure of name of interest and data packet. This name denotes the name of possessed data. Selectors adopt the same TLV structure of selector\cite{selector}. However, only parts of selectors including MinSuffixComponents, MaxSuffixComponents, PublisherPublicKeyLocator, Exclude, and ChildSelector are used in repo command parameter. The meaning of selectors is not the same in different operations which will be discussed in the following sections. StartBlockId and EndBlockId denotes the beginning and end of segment number to support segmented insertion and deletion. ProcessId is a random number generated to identify operation process. It is used for insertion and deletion status check.

\subsubsection{Repo Command Response}
Repo command response is the response data packet of repo command interest. The response contains statuscode to indicate the status of command process and other information. A TLV-encoded block called RepoCommandResponse is encoded in content block of the data packet. It defines as follows:

\begin{figure*}
\begin{framed}
\begin{BVerbatim}
RepoCommandResponse   ::= INSERTSTATUS-TYPE TLV-LENGTH
                           ProcessId?
                           StatusCode
                           StartBlockId?
                           EndBlockId?
                           InsertNum?
                           DeleteNum?

ProcessId             ::= PROCESSID-TYPE TLV-LENGTH
                            nonNegativeInteger

StatusCode            ::= STATUSCODE-TYPE TLV-LENGTH
                            nonNegativeInteger

StartBlockId          ::= STARTBLOCKID-TYPE TLV-LENGTH
                            nonNegativeInteger

EndBlockId            ::= ENDBLOCKID-TYPE TLV-LENGTH
                            nonNegativeInteger

InsertNum             ::= INSERTNUM-TYPE TLV-LENGTH
                            nonNegativeInteger

DeleteNum             ::= DELETENUM-TYPE TLV-LENGTH
                            nonNegativeInteger

\end{BVerbatim}
\end{framed}
\end{figure*}

The TLV structure and meaning of Name, ProcessId, StartBlockId, and EndBlockId are just like those of RepoCommandParameter. InsertNum is the count of data inserted. DeleteNum is the count of data erased. Statuscode is the number indicating the status of command. The detailed definition will be introduced in the following sections.

\subsubsection{Repo TLV Type Encoding Number}

In TLV encoding, first several bits defines the type of block. Table 1 shows these codes definition

\begin{table}[!hbp]
\centering

\begin{tabular}{l l}

\hline
type & number \\
\hline
RepoCommandParameter & 201 \\
StartBlockId & 204 \\
EndBlockId & 205 \\
ProcessId & 206 \\
RepoCommandResponse & 207\\
StatusCode & 208 \\
InsertNum & 209 \\
DeleteNum & 210 \\
\hline

\end{tabular}
\caption{Repo TLV Type Encoding Number}
\end{table}



\subsection{Authentication and Authorization}
The trust model and access control of repo depends on specific implementation. The protocol does not limit type of trust model. The implementation of repo can either adopt policy based or reputation based trust model for validation the repo command interest. The protocol only requests signature and timestamp for repo command interest. Access control is also defined by specific implementation. Public key in signature is a good identifier for access control list.

\subsection{Inserting Data and Insertion Status Check}

Repo insertion command requests that the repo retrieves and stores content from requester. Validation of commands is defined by specific implementation. When the intereste is validated and name of the data is not existed in the repo. The repo will response with a data object containing OK status and start to send the interest to fetch the data to insert.

Segmented data insertion is also supported in the insertion protocol. Segmentation information is defined in RepoCommandParameter.

Command of insertion status check is supported. Once the check command was sent, repo will return response about the first and the last of id of segmented data and how many blocks have been inserted. If EndBlockId Missing Timeout is allowed, this check command can also reset the timer to zero.

\subsubsection{2.5.1	Structure of Repo Insertion Command and Insertion Status Check Command}
The name semantics follows the format of the repo command. The ``<command verb>'' are defined as ``insert'' and ``insert check''. For example, for <repo prefix> as /ucla/cs/repo, the following are an examples of insertion and insertion check command:

\begin{figure*}
\begin{framed}
\begin{BVerbatim}

/ucla/cs/repo/insert/<RepoCommandParameter>/<timestamp>/<random-value>/<SignatureInfo>/<SignatureValue>

\end{BVerbatim}
\end{framed}
\end{figure*}

\begin{figure*}
\begin{framed}
\begin{BVerbatim}

/ucla/cs/repo/insert check/<RepoCommandParameter>/<timestamp>/<random-value>/<SignatureInfo>/<SignatureValue>

\end{BVerbatim}
\end{framed}
\end{figure*}


\subsubsection{RepoCommandParameter of Insertion Command}
RepoCommandParameter of insertion command follows TLV structure of RepoCommandParameter of repo command, but adopts only parts of sub TLV-block including, Name, Selector, StartBlockId, EndBlockId. The name section is a must section in this scenario.

\begin{itemize}
\item <Name> indicates the prefix of name of data that will be inserted into repo.
\item <Selector> indicates the selectors of interests for repo to fetch data.
\item <StartBlockId> indicates the first segment ID of segmented data to be inserted.
\item <EndBlockId> indicates the last segment ID of segmented data to be inserted.
\end{itemize}

\subsubsection{RepoCommandParameter of Insertion Check Command}
RepoCommandParameter of insertion check command follows TLV structure of RepoCommandParameter of repo command, but only and must adopt ProcessId.

\begin{itemize}
\item <ProcessId> is retrieved from the RepoCommandResponse of Insertion Command and it indicates the identity of the insertion progress.
\end{itemize}

\subsubsection{RepoCommandResponse of Insertion Command}
RepoCommandResponse of insertion command follows TLV structure of RepoCommandResponse. Once the interest arrives, repo will validate the repo command and check the authorization of the command. Then Repo will return the response according to the result of command validation. RepoCommandResponse of insertion adopts ProcessId, StatusCode, StartBlockId, EndBlockId, and InsertNum sections. StatusCode is the must section.

\begin{itemize}
\item <ProcessId> is generated when the interest is validated and authorized.
\item <StatusCode> indicates status of insertion status.
\item <StartBlockId> indicates the first segment ID of segmented data to be inserted.
\item <EndBlockId> indicates the last segment ID of segmented data to be inserted.
\item <InsertNum> indicates how many content objects have been inserted.
\end{itemize}

\subsubsection{RepoCommandResponse of Insertion Status Check Command}
RepoCommandResponse of insertion status check command follows TLV structure of RepoCommandResponse. Once the interest arrives, repo will validate the command interest and check the authorization of the command. Then Repo will check the insertion status according to ProcessId. RepoCommandResponse of insertion check adopts ProcessId, StatusCode, StartBlockId, EndBlockId, and InsertNum sections. StatusCode and ProcessId are the must sections.

\begin{itemize}
\item <ProcessId> is the same with that of insertion response.
\item <StatusCode> indicates status of insertion progress.
\item <StartBlockId> indicates the first segment ID of segmented data to be inserted.
\item <EndBlockId> indicates the last segment ID of segmented data to be inserted.
\item <InsertNum> indicates how many content objects have been inserted.
\end{itemize}

The following table shows the definition of StatusCode.

\begin{table}[!hbp]
\centering

\begin{tabular}{l l}

\hline
StatusCode & Description \\
\hline
100 & The command is OK. can start to fetch the data \\
200 & All the data has been inserted \\
300 & This insertion is in progress \\
401 & This insertion command or insertion check command is invalidated \\
402 & Selectors and BlockId both present\\
403 & Malformed Command \\
404 & No such this insertion is in progress \\
\hline

\end{tabular}
\caption{StatusCode of Insertion}
\end{table}

\subsubsection{Types of Insertion}
There are 3 types of supported insertion: name, selector and segment.

Name insertion means repo expresses interest just containing name of inserted data. Selector, StartBlockId and EndBlockId are all not set, except Name of RepoCommandParameter.

Selector insertion means inserting one content object conforming to Name as prefix and Selector. StartBlockId and EndBlockId will not be set. Name and Selector will be set.

Segment insertion means inserting multiple segmented content objects into the repo. Selector will not be set. At least one of StartBlockId and EndBlockId is set.

\subsubsection{EndBlockId Missing Timeout}
If StartBlockId presents but EndBlockId is missing, and returned data packets do not contain FinalBlockId, the repo will continuously fetch the data. An EndBlockId Missing Timeout is set to prevent this occasion. The repo will start a timer when StartBlockId presents but EndBlockId and FinalBlockId are missing. When timeout happens, repo will stop fetching data to store and end insert process. If an insert check command arrives during this insert process, the time of timer is set to 0. If data packet containing FinalBlockId arrives, this timeout timer will be dismissed.

\subsubsection{Insertion Protocol Process}

Progress of Inserting Data:

\begin{enumerate}[step 1]

\item Dtart to authorize the command; If authorization does not fail immediately, go to step 3

\item Send a negative response indicating authorization failure, and abort these steps, insert process ends (StatusCode: 401)

\item If both StartBlockId and EndBlockId are missing, go to step 7

\item If either StartBlockId or EndBlockId is present, and one of supported selectors is present. Send negative response back and abort steps, insert process ends (StatusCode: 402)

\item If both StartBlockId and EndBlockId are present, and StartBlockId is less than or equal to EndBlockId, go to step 7

\item Send a negative response indicating malformed command, and abort these steps, insert process ends (StatusCode: 403)

\item Wait for authorization completion

\item If authorization fails, go to step 2 (StatusCode: 401)

\item Send a positive response indicating insert is in progress (StatusCode: 200)

\item If either StartBlockId or EndBlockId is present, go to step 16

\item Start to retrieve Name with selectors in insert command

\item Wait for retrieval completion

\item If retrieval fails, go to step 27

\item Store retrieved Data packet

\item Abort these steps, insert process ends

\item If StartBlockId is missing, set StartBlockId 0. If EndBlockId is missing, EndBlockId will be missing unless get FinalBlockId in coming data packets, start EndBlockId Missing Timeout timer.

\item Append StartBlockId to Name

\item Start to retrieve Name

\item Wait for retrieval completion

\item If retrieval fails, go to step 26

\item Store retrieved Data packet

\item If retrieved Data packet contains FinalBlockId, and FinalBlockId is less than EndBlockId or EndBlockId is missing, let EndBlockId be FinalBlockId

\item If the last component of Name is greater than or equal to EndBlockId, abort these steps, insert process ends

\item Increment the last component of Name

\item Go to step 17

\item Retrieve data with this data another 2 times. If these 2 retrieval both fails, abort these steps. If success, go to step 21

\item Retrieve data with this data another 2 times. If these 2 retrieval both fails, abort these steps. If success, go to step 14
\end{enumerate}

If EndBlockId Missing Timeout timer starts, repo will monitor this timer during step 17~27. If this timeout occurs, abort insertion command process immediately.

Implementation MAY pipeline the Interests.

Progress of Insertion Check:

Implementation MAY publish a notification of status regarding insert progress. The process of insertion check is as follows:

\begin{enumerate}[step 1]

\item start to authorize the insert status command, if fails go to 2, if success, go to 3

\item send a negative response indicating authorization failure, and abort these steps (StatusCode: 401)

\item start to check the progress of the insert with the data name in the command. If no such progress is found, go to 4. or go to 5.

\item response status with status code, abort check process. (StatusCode: 404)

\item check the status of insertion. return the status of insertion progress. If a EndBlockId Missing Timeout timer is running, set this timer to 0. About check process. (StatusCode: 300)

\end{enumerate}

The figure 3 below shows the simple process of insertion.

\begin{figure*}
\centering
\includegraphics{Drawing3.eps}
\caption{Insertion and Insertion Status Check Progress}
\end{figure*}

\subsection{Deleting Data and Deletion Status Check}
Deletion of one content object or multiple content objects under certain prefix are both supported. Selectors can be used in deletion but have different semantics with those of insertion.

\subsubsection{Structure of Repo Deletion and Deletion Status Check Command}
The name semantics follows the format of the repo command. The ``<command verb>'' are defined as ``delete'' and ``delete check''. For example, for <repo prefix> as /ucla/cs/repo, the following are an examples of deletion and deletion check command:


\begin{figure*}
\begin{framed}
\begin{BVerbatim}

/ucla/cs/repo/delete/<RepoCommandParameter>/<timestamp>/<random-value>/<SignatureInfo>/<SignatureValue>

\end{BVerbatim}
\end{framed}
\end{figure*}

\begin{figure*}
\begin{framed}
\begin{BVerbatim}

/ucla/cs/repo/delete check/<RepoCommandParameter>/<timestamp>/<random-value>/<SignatureInfo>/<SignatureValue>

\end{BVerbatim}
\end{framed}
\end{figure*}

\subsubsection{RepoCommandParameter of Deletion Command}
RepoCommandParameter of deletion command follows TLV structure of RepoCommandParameter of repo command, and adopts all the sub-sections. The Name and ProcessId sections are the must sections in this scenario.

\begin{itemize}
\item <ProcessId> is generated by the deletion requester and it indicates the identity of the deletion progress.
\item <Name> indicates the prefix of name of data that will be deleted from repo.
\item <Selector> indicates the selectors of interests for repo to deleting data.
\item <StartBlockId> indicates the first segment ID of segmented data to be deleted.
\item <EndBlockId> indicates the last segment ID of segmented data to be deleted.
\end{itemize}

\subsubsection{RepoCommandParameter of Deletion Status Check Command}
RepoCommandParameter of deletion check command follows TLV structure of RepoCommandParameter of repo command, but only and must adopt ProcessId.

\begin{itemize}
\item <ProcessId> is that of deletion command to indicate the specific deletion progress.
\end{itemize}


\subsubsection{RepoCommandResponse of Deletion Command}
RepoCommandResponse of deletion command follows TLV structure of that of repo. Once the interest arrives, repo will validate the command interest and check the authorization of the command. Then Repo will start deletion prgress. When the deletion is finished, repo will return the response. RepoCommandResponse of deletion adopts ProcessId, StatusCode, StartBlockId, EndBlockId, and DeleteNum sections. StatusCode is the must section.

\begin{itemize}
\item <ProcessId> is generated by the deletion command interest;
\item <StatusCode> indicates status of deletion.
\item <StartBlockId> indicates the first segment ID of segmented data to be deleted.
\item <EndBlockId> indicates the last segment ID of segmented data to be deleted.
\item <DeleteNum> indicates how many content objects have been deleted.
\end{itemize}

\subsubsection{RepoCommandResponse of Deletion Status Check Command}
RepoCommandResponse of deletion check command follows TLV structure of RepoCommandResponse of repo. Once the interest arrives, repo will validate the command interest and check the authorization of the command. Then Repo will check the deletion status according to ProcessId. RepoCommandResponse of deletion check adopts ProcessId, StatusCode, StartBlockId, EndBlockId, and DeleteNum sections. StatusCode and ProcessId are the must sections.

\begin{itemize}
\item <ProcessId> is the same with that of deletion command.
\item <StatusCode> indicates status of deletion.
\item <StartBlockId> indicates the first segment ID of segmented data to be deleted.
\item <EndBlockId> indicates the last segment ID of segmented data to be deleted.
\item <DeleteNum> indicates how many content objects have been deleted.
\end{itemize}

The following table shows the definition of StatusCode.

\begin{table}[!hbp]
\centering

\begin{tabular}{l l}

\hline
StatusCode & Description \\
\hline
200 & All the data has been deleted \\
300 & This deletion is in progress \\
401 & This deletion or deletion check command is invalidated \\
402 & Selectors and BlockId both present\\
403 & Malformed Command \\
404 & No such this deletion  is in progress \\
\hline

\end{tabular}
\caption{StatusCode of Deletion}
\end{table}

\subsubsection{Types of Deletion}
There are 3 types of supported deletion: name, selector and segment.

Name deletion means deleting all the content objects with Name as their prefix. Selector, StartBlockId and EndBlockId are all not set, except Name of RepoCommandParameter.

Selector deletion means deleting any content object conforming to Name as prefix and Selector. StartBlockId and EndBlockId will not be set. Name and Selector will be set.

Semantics of selectors in this case is different. In this case, the selector will match all the content objects conforming to the selector conditions not just one content object.

Segment deletion means deleting multiple segmented content objects from the repo. Selector will not be set. At least one of StartBlockId and EndBlockId is set.


\subsubsection{Deletion Protocol Process}

Progress of Deleting Data:

\begin{enumerate}[step 1]

\item Start to authorize the command; If authorization does not fail, go to step 3

\item Send a negative response indicating authorization failure, and abort these steps, end deletion process. (StatusCode: 401)

\item Check whether a deletion process of same RepoCommandParameter exists, waiting for deletion process ends.

\item If selectors and one of StartBlockId and EndBlockId presents, send a negative response and abort these steps, end deletion process. (StatusCode: 402)

\item If selectors present, go to step 8

\item Check whether StartBlockId or EndBlockId presents. If both presents but StartBlockId is larger than EndBlockId, return negative response and end deletion process. (StatusCode: 403) Or go to step 9

\item If StartBlockId, EndBlockId and selectors are all missing, go to step 10

\item Delete all the data that conforms to the name and selectors, go to step 11

\item Delete all the data packets of segment id between StartBlockId and EndBlockId. If StartBlockId is missing, StartBlockId is set to be 0. If EndBlockId is missing, EndBlockId is set to be the largest segment id that repo holds. go to step 11

\item Delete data with prefix of Name. Go to step 11

\item If lifetime of interest does not expire, return status response of positive StatusCode. If lifetime of interest has expired, wait for interest the same RepoCommandParameter and return this status response. End Deletion process. (StatusCode: 200)

\end{enumerate}

Requester will set deletion command with big lifetime. The repo will also hold the status of deletion progress for certain duration after deletion done. If lifetime expires, client will re-express the command to get the response.

Implementation MAY publish a notification of status regarding delete progress. The process of status check is as follows:

\begin{enumerate}[step 1]

\item Start to authorize the delete status command

\item Send a negative response indicating authorization failure, and abort these steps (StatusCode: 401)

\item Start to check the progress of the delete with the data name in the command. If no such progress is found, go to 4. or go to 5.

\item Response status with status code of 404 (StatusCode: 404)

\item Check the status of delete. Return the status data content (StatusCode: 300)

\end{enumerate}

\begin{figure}
\centering
\includegraphics{Drawing4.eps}
\caption{Deletion and Deletion Status Check progress}
\end{figure}


\section{REPO-NG DESIGN}
Repo-ng (NDN repo of new generation) is an implementation of NDN persistent in-network storage conforming to NDN Repo protocol. It uses ndn-cxx as NDN client library and database Sqlite3 as underlying data storage.

\subsection{Supported Feature}

Besides supporting repo protocol, repo-ng has some tools to manipulate repo and some other features for upper application.
\begin{enumerate}
\item Get, put and delete file: tools to get, put and delete (to do) a file from repo
\item Sync: use ChronoSync \cite{zhu2013let} to synchronize data objects among different repos
\end{enumerate}

\subsection{Software Structure}

Major Modules:
\begin{itemize}
\item Storage: basic interfaces to handle storage related operations including reading, insertion, update and deletion. It also operates on NDN packets according to selectors bound with interests. This module locates in src/storage directory. The storage of repo-ng consists of index and database storage in current design which will be demonstrated more specifically in next section.
\item Handle: Handle module can handle interests or commands of different functions separately. Reading is supported in read-handle, insertion and insertion status check in write-handle and deletion and deletion status check in delete-handle. This module locates in src/handle directory.
\item Helpers: repo command parameter, response and repo TLV formats are defined in this module.
\item Server: The process of starting a repo is defined  including reading configuration file, initiating database, connection to NFD and registration of prefixes.
\item Test: unit-test and integrated tests are both supported
\item Tool: command line tools to use repo such as tools to fetch a file from, to dump a file into the repo and so on.
\end{itemize}

\subsection{Repo Storage Design}
The design of data packet storage of repo-ng consists of index and storage components. Index is sorted associative container for Name stored in memory and storage is consistent storage for read, write and delete of data packet.

Underlying storage offers structured API for retrieval, adding and removal of data packets. Sqlite3 is chosen to be the underlying storage for its well cross-platform, self-contained, serverless, and zero-configuration properties. The structure of a set of data packet is (Id, Data packet). The Id is the unique integer representing the data packet.

Index offers fast query of interest in memory. When an interest comes to repo, repo will query the index with the name and selector to select the id of data packet which is consistent with that of underlying storage. The structure of one entry of index is (Id, Name, KeyLocatorHash). Name is the name of data packet. KeyLocatorHash is the hash of key locator of data packet.

In current repo-ng design, the data structure of repo-index is skip list. \cite{pugh1990skip} Although skip list, Btree and other balanced tree all have O(n) query and insertion complexity, skip list has very low inherent constant-factor overheads. Besides, operations of skiplist are much easier to implement.


Repo-ng adopts in-memory index, so when the repo restarts, it will rebuild from sqlite3 database file.

\subsection{Supported Repo Protocol Features}
Most parts of the protocol are supported in repo-ng. The following features are not supported in current version.

\begin{itemize}

\item For deletion command, if EndBlockId is null in RepoCommandParameter, repo just returns RepoCommandResponse with StatusCode 403 (Malformed Command).

\item Command for checking deletion Status

\end{itemize}

\subsection{Tust Model and Access Control}

\subsubsection{Tust Model}

Command Interest and Data Packet can both be validated by repo-ng. Whether or not validating is an option that can be configured. However, validation of command interest is highly recommended. In repo-ng implementation, ``validator-config'' which is part of NDN basic library ``ndn-cxx'' is used as validator. The configuration file follows the format of validconf. \cite{validconf}

\subsubsection{Access Control}
When a command interest is coming, each interest would be matched in Access Control List (ACL) to interest one by one, the best-matched rele is found. The design of ACL is referred to the format of validconf \cite{validconf}. Filter and checker are also defined in one rule. First, filter will check the prefix of the command interest to match the rule. Then filter will check the authorization of this filter according to the checker.

Here is an example of the rule.

\begin{figure}[!hbp]
\begin{framed}
\begin{BVerbatim}
rule
{
  filter
  {
    name /localhost/example
    relation is-prefix-of
  }
  checker
  {
    {
      name /localhost/example
      relation is-prefix-of
      auth wd
    }
  }
}

rule
{
  for interest
  filter
  {
    name /localhost/example
    relation is-prefix-of
  }
  checker
  {
    {
      name /localhost/example
      relation is-prefix-of
      auth wd
    }
  }
}

\end{BVerbatim}
\end{framed}
\end{figure}

There are 3 kinds of relations in the filter.

\begin{enumerate}
\item equal: The repo prefix of command interest is equal to filter.
\item is-strict-prefix-Of: The filter is prefix of but not equal to the repo prefix.
\item is-prefix-of: The filter is prefix of the repo prefix.
\end{enumerate}

The priority is equal > is-strict-prefix-Of > is-prefix-of.

The rule would be sorted according to the name in the filter in canonical order. If the name is the same, rule would be sorted according to the priority of the relation. Command interest will match the filter of the advanced rule.

Checker will check the authorization of the command interest for certain prefix of data. Checker will extract the name in repo command parameter. If the data name match the checker, the interest would have the authorization in auth section.

There are 2 kind of authorization: w, d. W means the command could insert data of this prefix. D means the command could remove data of this prefix from repo.

If command interest does not fit and filter or any checker, it means command interest has no access to the repo.

\subsection{Congestion Control}
In process of insertion, after repo receiving the insertion command for segmented data, it will send multiple interests for data packets. If these interests are sent in a burst, the round trip time will be large for some interests and it is difficult to set interest lifetime. So congestion control is necessary.

A basic credit based congestion control is implemented for insertion command. There is credit number to count the waiting interest request. Once an interest is sent, the credit minus one and if an interest is satisfied by one data. If credit is equal or less than 0, the repo stops sending interests. The original credit number could be adjusted according to the count of interest on the wire.

In addition, if an interest is timeout. The same interest could be retransmitted for certain times that can be configured. The retransmitted interest will not subtract the credit.

Besides, our performance test tool ndnputpacket which put certain mount of packets of assigning size into the repo, also adopts this congestion control solution.

The flow chart of this congestion control is as follows:

\begin{figure*}
\centering
\includegraphics{Drawing5.eps}
\caption{Process of Congestion Control}
\end{figure*}

\section{EVALUTATION OF REPO-NG}

In this section, the performance of repo-ng including is evaluated. The speed of data fetching, insertion and deletion of data packets are measured. In addition, comparison between repo-ng over NFD platform and ccnr over ccnd platform are conducted.

Tests are conducted on the following hardware platform:

HP Z220 worksatation with 3.4 GHz Intel Core i7 processor of 8 cores, 16GB memory, 2T hard drive with 7200rpm, Ethernet Card 1000Mbps.
Lenovo notebook with with 1.74GHz Intel Core i3 processor of 2 cores, 2GB memory, 500G hard drive with 7200rpm, Ethernet Card 1000Mbps.

Software platform:
For repo-ng, it is developed by ndn-cxx \cite{ndn-cxx} which is NDN C++ library with eXperimental eXtensions. The forwarding deamon of repo-ng is NFD. \cite{NFD} Ccnr uses ccnd \cite{ccnd} as forwarding deamon. All the software runs on Ubuntu 13.10.

\subsection{Local Access}

Repo-ng and ccnr both supports retrieving and inserting data packets, but repo-ng also supports deleting data packets from repo. In this section, all the operations are tested on one hosts. The data packets are directly generated in memory to avoid hard drive I/O overhead. Access control is not configured. The following are scenarios of tests:

\begin{enumerate}[a]
\item Put $10^3$, $10^4$, $10^5$, $10^6$ data packets with 1200 bytes of data content into a clean repo-ng. Validation is off.
\item Put $10^3$ data packets with $10^3$. Insert commands into a clean repo-ng with and without validation.
\item Retrieve $10^3$, $10^4$, $10^5$, $10^6$ data packets from repo-ng which carries $10^3$, $10^4$, $10^5$, $10^6$ data packets of 1200Bits.
\item Remove $10^3$, $10^4$, $10^5$, $10^6$ data packets from repo-ng which carries $10^3$, $10^4$, $10^5$, $10^6$ data packets of 1200Bits. Validation is off.
\item Rebuild index from $10^3$, $10^4$, $10^5$, $10^6$ data packets from database file.
\item Put $10^3$, $10^4$, $10^5$, $10^6$ data packets with 1200 bytes of data content into a clean ccnr.
\item Retrieve $10^3$, $10^4$, $10^5$, $10^6$ data packets from ccnr which carries $10^3$, $10^4$, $10^5$, $10^6$ data packets of 1200Bits.
\end{enumerate}

Table 4 shows the results of repo-ng speed from case a to case e. The unit of result is MBps. ``put -s'' and ``put-s-v'' mean insert commands into a clean repo-ng with and without validation

\begin{table}
\centering
\begin{tabular}{ | c | c | c | c | c | c | c | }
    \hline
           & put & get & remove & rebuild & put-s & put-s-v \\ \hline
    $10^3$ & 0.692 & 16.881 & 15.584 & 120 & 0.041 & 0.038  \\ \hline
    $10^4$ & 0.715 & 16.585 & 25.974 & 153.846 & & \\ \hline
    $10^5$ & 0.719 & 16.634 & 29.843 & 158.521 & & \\ \hline
    $10^6$ & 0.713 & 12.918 & 26.266 & 95.610 & &\\ \hline
\end{tabular}
\caption{Local Access of Repo-ng}
\end{table}

Table 5 shows the the results of ccnr speed from case f to case g

\begin{table}
\centering
\begin{tabular}{ | c | c | c | }
    \hline
           & put & get \\ \hline
    $10^3$ & 1.336 & 0.869 \\ \hline
    $10^4$ & 8.778 & 4.180 \\ \hline
    $10^5$ & 24.995 & 13.258 \\ \hline
    $10^6$ & 28.323 & 18.266 \\ \hline
\end{tabular}
\caption{Local Access of Ccnr}
\end{table}

Table 4 and 5 shows the comparison of throughput between repo-ng and ccnr. The speed of insertion of ccnr is far more higher than that of repo-ng. One of main reason is the underlying storage of these systems. The storage of ccnr is rather simple by appending new content objects in the ccnr file. In repo-ng design, it would support more complex query (selector) of data packets, so it adopts structured storage database. The process of database insertion is far more complex than just appending a file. The speed of fetching is comparable between repo-ng and ccnr. As we notice that, the speed of fetching drops a little as the mounts of packet grows. The index of repo-ng is based on skiplist. It will took more time when index gets larger. Besides, query of database will get slower when data gets larger.

Table 4 also shows the speed of possessing multiple commands. It takes 29.468s and 31.619s to possess 1000 insetion commands with and without validation. The time cost of insertion data packets into database could be dismissed. It takes about 30ms to possess a command locally. In our validation case, the repo-ng directly validated commands and data packets using the local certificate file. As we can see, the time cost of validation is rather low.

\subsection{Network Access}
HP Z220 and the notebook are directly connected. Notebook works as client and repo-ng runs on HP Z220. Case a to case d in local access section are tested as table 6 shows.

\begin{table}
\centering
\begin{tabular}{ | c | c | c | c | c | c | }
    \hline
           & put & get & remove & put-s & put-s-v \\ \hline
    $10^3$ & 0.396 & 2.230 & 8.053 & 0.033 & 0.032  \\ \hline
    $10^4$ & 0.423 & 3.490 & 21.898 & & \\ \hline
    $10^5$ & 0.0.424 & 3.476 & 24.964 & & \\ \hline
\end{tabular}
\caption{Local Access of Ccnr}
\end{table}

Compared with local access, the speed drops due to the network latency between the two hosts. However, we can see a great speed drop on retrieving data packets. Different resources of client and repo are tested to track down the performance bottleneck. We see that the  load of client CPU usage is up to 70\%. This is caused by the process of inserting data. When inserting data into the repo, repo will issues multiple interests for each data packet. The possessing of these interests would be a great load for the low hardware setting notebook.

Repo-ng is just one-thread process for now. There is some inefficiency to serve multiple client. For data retrieval, the cost of possessing each interest is little, so this one-thread design would not impact much. However, insertion or removal of large mount of data packets would block the repo-ng process for a certain time, while repo-ng cannot possess other data handle requests during this time.  Therefore, a time-cost process may cost congestion. Multi-thread or other types of asynchronous design should be adopted in future.

\section{Functional Evaluation}

Ccnr just supports local data fetching and inserting. Compared to ccnr, repo-ng of NDN supports more functions listed as below.

\begin{itemize}
\item Local and remote data retrieval, insertion and removal of repo with certain name.
\item Status check of data insertion and removal.
\item More complex data possessing including segmented data and interest with selectors.
\item Authorization and Access Control. Repo-ng could validates command and data packets according to users' configuration. Access control can also be supported by user defined policy.
\end{itemize}

\section{CONCLUSION AND FUTURE WORK}

In this paper, the protocol of NDN repo is demonstrated and an implementation of NDN protocol, repo-ng is developed. Compared to CCNx Repository Protocols, NDN repo supports more functions and provides validation and access control. The design of repo-ng is demonstrated and evaluation shows the efficiency between ccnr and repo-ng. Although repo-ng is less efficient in simple data packets retrieval and insertion, it provides more functions especially remote operations.

NDN Repo protocol is a rather simple protocol which just supports one-to-one operation. Control over repos with same name prefix is less efficient. Besides, protocol of synchronization among different repos is necessary for applications like online chat.

Repo-ng is one-thread process for now and this would cost request congestion when each request costs too much time. Mutti-thread and request waiting queue would be developed in future to optimize the performance.

\bibliographystyle{abbrv}
\bibliography{repo}

\end{document}
